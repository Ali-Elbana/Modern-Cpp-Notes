## <font color="yellow"><u>Introduction:</u></f>

- **Overloaded functions**: When overloaded functions are called, the compiler must determine which function matches the call. This process becomes complex when functions have the same number of parameters but different types that may require conversions.

#### Example:
```cpp
void f();
void f(int);
void f(int, int);
void f(double, double = 3.14);
f(5.6);  // Calls void f(double, double)
```

---
## <font color="yellow"><u>Determining Candidate and Viable Functions:</u></f> 

1. **Candidate Functions**: These are functions with the same name as the called function and a visible declaration. In the example, the candidate functions are `f()`, `f(int)`, `f(int, int)`, and `f(double, double)`.

2. **Viable Functions**: To be viable, the function must have the same number of parameters as arguments in the call, and the arguments must either match or be convertible to the parameter types. In the example:
   - `f()` and `f(int, int)` are **not viable** because they have 0 and 2 parameters, while the call has 1 argument.
   - `f(int)` and `f(double, double)` are **viable**:
     - `f(int)` is viable due to a conversion from `double` to `int`.
     - `f(double, double)` is viable because its first parameter is `double` (matching the argument type), and it has a default argument for the second parameter.

3. **No Matching Function**: If no viable functions are found, the compiler will generate an error stating that no matching function exists.

---
## <font color="yellow"><u>Finding the Best Match:</u></f> 

The compiler checks each viable function to determine the **best match** by comparing how closely the argument types match the parameter types:

- **Exact match** is better than a match requiring a conversion.
- In the example, `f(5.6)` calls `f(double, double)` because it is an exact match for the argument, while calling `f(int)` would require converting from `double` to `int`.

---
## <font color="yellow"><u>Function Matching with Multiple Parameters:</u></f> 

When there are multiple arguments, function matching becomes more complicated. For example:
```cpp
f(42, 2.56);  // Calls are ambiguous
```

The viable functions are `f(int, int)` and `f(double, double)`:
- For the first argument:
  - `f(int, int)` is an **exact match** for `42` (an `int`).
  - `f(double, double)` requires a conversion from `int` to `double`, which is less ideal.
- For the second argument:
  - `f(double, double)` is an **exact match** for `2.56` (a `double`).
  - `f(int, int)` requires a conversion from `double` to `int`, which is less ideal.

Since each function is a better match for one argument but worse for the other, the compiler will reject this call as **ambiguous**.

---
## <font color="yellow"><u>Argument Type Conversions:</u></f> 

To determine the best match, the compiler ranks conversions from the argument type to the parameter type:
1. **Exact match**: Types are identical or can be converted directly.
2. **Const conversion**.
3. **Promotion**: Small integral types promote to larger types (e.g., `char` to `int`).
4. **Arithmetic or pointer conversion**.
5. **Class-type conversion**: Involves user-defined conversions between types.

#### Promotions and Conversions:

- **Promotions** (e.g., `char` to `int`) and other conversions between built-in types can cause ambiguities in function matching.
- Example:
```cpp
void ff(int);
void ff(short);
ff(’a’); // char promotes to int; calls f(int)
```
- Example:
  ```cpp
  void manip(long);
  void manip(float);
  manip(3.14);  // Error: ambiguous call
  ```
  In this case, `3.14` (a `double`) can be converted to either `long` or `float`, resulting in an ambiguous call.

---

## <font color="yellow"><u>Function Matching and `const` Arguments:</u></f> 

The `const` qualifier influences function matching when overloaded functions differ based on whether a parameter is `const`.

Example:
```cpp
Record lookup(Account&);
Record lookup(const Account&);

const Account a;
Account b;

lookup(a);  // Calls lookup(const Account&)
lookup(b);  // Calls lookup(Account&)
```

- The first call matches `lookup(const Account&)` because `a` is `const`.
- The second call matches `lookup(Account&)` because `b` is non-`const`. If the `const` version were chosen, it would require a conversion, making it less ideal.

Similarly, when functions are overloaded based on pointer types (`const` vs. non-`const`), the compiler uses the **constness** of the argument to choose the appropriate function.

---
